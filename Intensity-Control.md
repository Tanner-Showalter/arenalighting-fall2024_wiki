# Intensity Control
Intensity control enables the user to apply glowing effects to the orbs. Such effects include blinking, fading, and pulsing. The technical aspects of this feature are adding the post-processing layers to the main camera, setting a default level of intensity to materials (LED orbs in this case), enabling/disabling the emission setting on each of those orbs, and creating a set of functioning UI buttons/toggles. 

## Developer's Guide
### Iteration 1 | Basic Features
Setting up a glowing, light-emitting effect involved installing the post-processing package, adding the post-processing component to the main camera, adding the post-processing layer to the main camera, and creating a bloom profile to control light intensity and diffusion. From there, clicking the emission check box on any/all materials and entering the HDR settings allows the user to manually increase or decrease the glowing effect by changing the intensity value. The desired emission intensity level we have found is between 2.5-3. 

To create the buttons to automatically turn on/off the glowing effect, I wrote a simple C# script and manually added to buttons to the UI. As did Devin, I used Unity’s onClick.AddListener() function to trigger the buttons when clicked, and iterated through each material tagged with ‘LED’ so each orb would be affected the same. When the ‘fade’ button is clicked, the keyword _EMISSION is disabled for each material tagged LED and conversely, when the ‘glow’ button is clicked, the _EMISSION keyword is enabled for those same materials. The script was then applied to the two buttons already manually created.

### Iteration 2 | Flash and Pulse
Building off the glow and fade button functions, creating the flashing effect was simple. As before, the flash button involved creating a UI button called FlashButton and a new onClick.AddListener(), which calls the flash() method this time. The flash() method uses a public boolean variable to determine if the lights are currently flashing or not and, if that variable is false, executes Unity’s InvokeRepeating() function to repeatedly call the fade function (starting at 0 seconds, then repeating every 1 second) and the glow function (starting at 0.5 seconds, then also repeating every 1 second). This gives the lights a flashing effect as they switch off and on every half second. If the lights are currently flashing and the boolean variable is true, then Unity’s CancelInvoke() function is called, and all active invokes are terminated. 

The pulsing effect toggle was more difficult to learn and implement. Instead of a UI button and onClick.AddListener, this effect was created using a UI toggle and the Update() function. First, variables for pulse speed, starting color and an animation curve (BrightnessCurve) were established. Every frame, the update() function checks if the pulseToggle is active using the .isOn feature. If the toggle is active, a scaled time variable is calculated (game time multiplied by the set pulse speed), each LED-tagged game object is found and the current color for those LEDs is now the starting color. To actually create the pulsing effect, the Evaluate() function was implemented to capture the time along the BrightnessCurve. This result is captured in the float variable brightness. Then, using the Mathf.Pow() feature, the RGBA color values for each LED are multiplied by the brightness squared. Next, using SetColor(“_EmissionColor”), the new RGBA values are applied to each LED orb. Finally, through the UI, a template brightness curve was used to make the lights slowly fade in and out on a loop.

In addition to the pulse toggle, a pulse speed input was also implemented. This input field is built with Unity’s onEndEdit function, which takes the float variable pulseSpeed and changes its value from the default 1.0 to the new input provided by the user. To do this, a method named setPulseSpeed was created to take the input value as a string, then parse the input into a float and set pulseSpeed to that new float value. The inputted pulseSpeed value is then used in the calculation for the BrightnessCurve discussed earlier.
